\chapter{Detalles de ImplementaciÃ³n y Experimentos}\label{chapter:implementation}
El objetivo de esta tesis es comparar dos de las heuristicas integradas a CDCL, en este caso, dos de las que intentan dar soluci/'on al problema de selecci/'on de variables: Dichas estrategias, VSIDS y DLIS, son comparadas usando \textit{restart} y no.

En el trabajo se usaron los lenguajes de programaci/'on C++, Python y bash. CaDiCaL est/'a programado en C++, por lo que es el lenguaje en el que est/'an implementadas las heur/'isticas. Python fue usado para automatizar los procesos de pruebas, guardar los resultados obtenidos y realizar los an/'lisis estad/'sticos. Finalemnte, bash se usa como parte de la "compilaci/'on" del solver, cuyos archivos como \textit{configure} y \textit{makefile} que vienen integrados al \textit{solver}, son los encargados de hacerlo funcionar.

\section{CaDiCaL}
CaDiCaL fue el \textit{solver} escogido para esta comparaci/'on, ya que cuenta con la posibilidad de activar y desactivar VSIDS (ya viene integrada), al igual que la estrategia \textit{restart}, tambi/'en integrada en el solucionador.\footnote{Cabe destacar que CaDiCaL ofrece esta misma posibilidad para much/'isimas heur/'sticas, adem/'as de estrategias para adaptar la v/'a de soluci/'on al tipo de problemas (citar documentaci/'n de CaDiCaL)} Como ya se mencion/'o con anterioridad en este documento, pr/'acticamente todos los CDCL SAT \textit{solvers} modernos no incluyen DLIS como heur/'istica de selecci/'on de variables, y CaDiCaL es uno de ellos. Por esta raz/'on, se decidi/'o integrar una implementaci/'on de DLIS a este solucionador, aprovechando la pol/'itica \textit{open source} de su c/'odigo fuente.%insertar link al repo original de cadical.

\subsection{Integraci/'on de DLIS}
Para integrar DLIS en CaDiCaL se modificaron los siguientes archivos:
\begin{itemize}
    \item \textit{internal.hpp}
    \item \textit{internal.cpp}
    \item \textit{decide.cpp}
    \item \textit{options.hpp}
\end{itemize}

\subsubsection{\textit{internal.hpp}}
En este archivo se declaran los m/'todos que ser/'an implementados como parte de la clase \textit{Internal}:

\begin{lstlisting}
  // DLIS
  int next_decision_variable_with_dlis ();
  int count_literal_in_unsatisfied_binary_clauses(int lit);
\end{lstlisting}

\subsubsection{\textit{internal.cpp}}
En \textit{internal.cpp} se a/~nadi/'o el siguiente c/'odigo que contiene la l/'ogica de funcionamiento de DLIS.
CaDiCaL almacena las variables de la FNC en una lista doblemente enlazada, en la que aquellas que ya han sido asignadas y las que a/'un no tienen un valor definido se encuentran separadas en dos grupos (dentro de la misma lista) separadas por un /'indice que marca el l/'mite entre ellas. Este valor va cambiando con cada asignaci/'on. Haciendo uso de esta estructura, el siguiente m/'etodo se encarga de comparar la ocurrencia, en cl/'ausulas insatisfechas, de los literales correspondientes a las variables sin asignar, y elige el de valor m/'aximo.

\begin{lstlisting}[escapechar=!., language=C++]
int Internal::next_decision_variable_with_dlis () {
  int best_lit = 0;
  int best_score = -1;

  //Empezamos en el primer nodo ``no asignado'' de la cola
  int idx = queue.unassigned;

  // Recorremos la lista de variables sin asignar (link(idx).prev nos lleva
  //al siguiente ``sin asignar''), igual que en next_decision_variable_on_queue().
  while (idx) {
    // Si idx ya tiene val(idx) != 0, saltemos (aunque en teor\'ia queue.unassigned
    // siempre apunta a un idx tal que val(idx)==0; no obstante, por seguridad lo comprobamos).
    if (val(idx) == 0) {
      // Calcular la puntuaci'\on DLIS para +idx y para -idx
      int pos_score = count_literal_in_unsatisfied_binary_clauses(idx);
      int neg_score = count_literal_in_unsatisfied_binary_clauses(-idx);

      // Comparar con el mejor hasta ahora
      if (pos_score > best_score) {
        best_score = pos_score;
        best_lit   = idx;    // literal positivo
      }
      if (neg_score > best_score) {
        best_score = neg_score;
        best_lit   = -idx;   // literal negativo
      }
    }
    // Avanzamos al siguiente \'indice ``no asignado'':
    idx = link(idx).prev;
  }

  LOG ("next DLIS decision literal %d with score %d", best_lit, best_score);
  return abs(best_lit);
}
\end{lstlisting}
Como puede observarse, este m/'etodo hace un llamado a \begin{lstlisting}
count_literal_in_unsatisfied_binary_clauses(idx)
\end{lstlisting} 
que es el encargado de realizar el conteo de ocurrencias de literales por variable sin asignar, por cl\'ausula insatisfecha.

\begin{lstlisting}[escapechar=!., language=C++]
/// Cuenta ocurrencias de un literal 'lit' en cl\'ausulas binarias
/// no basura y no satisfechas, optimizando la llamada a val(lit).
int Internal::count_literal_in_unsatisfied_binary_clauses (int lit) {
  int count = 0;
  // Cacheamos una sola vez el valor de 'lit'.
  const signed char val_lit = val (lit);
  // Recorremos su lista de watchers
  const Watches &ws = watches (lit);
  for (const Watch &w : ws) {
    if (!w.binary ()) continue;          // Solo cl\'ausulas binarias
    Clause *c = w.clause;                
    if (!c || c->garbage) continue;      // Saltar nulos y garbage
    int other = w.blit;                  // El otro literal de la cl\'ausula
    // Si 'lit' o 'other' ya son verdaderos, la cl\'ausula est\'a satisfecha
    if (val_lit > 0 || val (other) > 0) continue;
    ++count;
  }
  return count;
}
\end{lstlisting}

Es importante aclarar que el c/'alculo del \textit{score} de cada literal no se hace tal cual dicta DLIS, pues en aras de mantener la consistencia del c\'odigo con la implementaci/'on de CaDiCaL se usaron estrategias y estructuras que ya vienen implementadas, y a las cuales se acoplan las heur/'isticas de decisi/'on de variables que iya incorpora el solucionador. Por ejemplo, en el c/'odigo anterior puede verse que el recorrido para efectuar el conteo de ocurrencias de un literal no se realiza sobre todas las cl\'ausulas insatisfechas, sino que, haciendo uso de la estrategia \textit{Two Watched Literals} (TWL) (hacer referencia al marco te\'orico) 

(assumptions--> hacer referencia a donde se explican en el marco teorico)

\subsection{Empleo de \textit{flags} en la l/'inea de comandos}
Los \textit{flags} usados en la l/'inea de comandos para combinar las heur/'isticas fueron:

\section{Problemas}
\section{Generador de problemas}
\section{Estad/'isticas}
